教程地址：https://es6.ruanyifeng.com/#docs/let#const-%E5%91%BD%E4%BB%A4
1、let和const命令
    1）基本用法：声明变量
    2）let命令：
        块级作用域：所声明的变量，只在let命令所在的代码块内有效；
        不存在变量提升：必须先声明再使用；
        暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的（主要场景为父级作用域已声明，子级作用域再次声明，在子级作用域声明前的区域）
            var tmp = 123;

            if (true) {
            tmp = 'abc'; // ReferenceError
            let tmp;
            }
        不允许重复声明：不允许在相同作用域内，重复声明同一个变量
    3）块级作用域：一个大括号包围的区域；
        *注意：在浏览器中实现的ES6有特殊规定：
            允许在块级作用域内声明函数。
            函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
            同时，函数声明还会提升到所在的块级作用域的头部。

    4）const命令：
        常量：一旦声明，常量的值就不能改变
        作用域、暂时性死区：同let
        本质：const保证的是变量指向的那个内存地址所保存的数据不得改动，简单类型数据（数值、字符串、布尔值），内存地址保存的是数据，复合类型（主要是对象和数组），内存地址保存的是数据的引用；
    5）顶层对象和全局变量：
        顶层对象：在浏览器环境指的是window对象，在 Node 指的是global对象
        属性关系：var命令和function命令声明的全局变量，顶层对象的属性；let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
2、变量的解构赋值
    定义：按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
    1）数组的解构赋值：本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
            let [foo, [[bar], baz]] = [1, [[2], 3]];
            foo // 1
            bar // 2
            baz // 3

            let [ , , third] = ["foo", "bar", "baz"];
            third // "baz"

            let [x, , y] = [1, 2, 3];
            x // 1
            y // 3

            let [head, ...tail] = [1, 2, 3, 4];
            head // 1
            tail // [2, 3, 4]

            let [x, y, ...z] = ['a'];
            x // "a"
            y // undefined
            z // []
        默认值：
            let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
            *注意：ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
    2）对象的解构赋值：
            let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
            foo // "aaa"
            bar // "bbb"
        不同：数组解构按顺序依次赋值，对象解构同名赋值；
        特殊：变量名与属性名不一致时，
            let obj = {
                p: [
                    'Hello',
                    { y: 'World' }
                ]
            };

            let { p, p: [x, { y }] } = obj;
            x // "Hello"
            y // "World"
            p // ["Hello", {y: "World"}]
        默认值：var {x = 3} = {};
                x // 3      
    3）字符串的解构赋值：
        const [a, b, c, d, e] = 'hello';
        a // "h"
        b // "e"
        c // "l"
        d // "l"
        e // "o"
    4）数值和布尔值的解构赋值
        重要：解构赋值时，如果等号右边是数值和布尔值，则会先转为对象
        let {toString: s} = 123;
        s === Number.prototype.toString // true

        let {toString: s} = true;
        s === Boolean.prototype.toString // true
    5）函数参数的解构赋值
        function add([x, y]){
            return x + y;
        }

        add([1, 2]); // 3
3、字符串扩展
    1）字符的 Unicode 表示法
    JavaScript 共有 6 种方法可以表示一个字符：
        '\z' === 'z'  // true
        '\172' === 'z' // true
        '\x7A' === 'z' // true
        '\u007A' === 'z' // true
        '\u{7A}' === 'z' // true
    2）字符串的遍历器接口
        添加for...of循环遍历，可以识别大于0xFFFF的码点。
    3）直接输入 U+2028 和 U+2029
        '中' === '\u4e2d' // true
    4）JSON.stringify() 的改造
        如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。
        JSON.stringify('\u{D834}') // ""\\uD834""
        JSON.stringify('\uDF06\uD834') // ""\\udf06\\ud834""
    5）模板字符串``
        模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量，变量名写在${}之中
    6）标签模板
        模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串
        alert`hello`
        // 等同于
        alert(['hello'])
4、字符串的新增方法
    1）String.fromCodePoint()：从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符
    2）String.raw()：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法
    3）codePointAt()：能够正确处理 4 个字节储存的字符，返回一个字符的码点。
    4）normalize()：用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。
    5）includes()：返回布尔值，表示是否找到了参数字符串。
        startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
        endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
    6）repeat()：返回一个新字符串，表示将原字符串重复n次
    7）padStart()，padEnd()：padStart()用于头部补全，padEnd()用于尾部补全
    8）trimStart()，trimEnd()：trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格
    9）matchAll()：返回一个正则表达式在当前字符串的所有匹配
    10）replaceAll()：一次性替换所有匹配。
5、正则的扩展
    1）RegExp 构造函数
        如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
        new RegExp(/abc/ig, 'i').flags
        // "i"
    2）字符串的正则方法
        ES6 将match()、replace()、search()和split()这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上
            String.prototype.match 调用 RegExp.prototype[Symbol.match]
            String.prototype.replace 调用 RegExp.prototype[Symbol.replace]
            String.prototype.search 调用 RegExp.prototype[Symbol.search]
            String.prototype.split 调用 RegExp.prototype[Symbol.split]
    3）u 修饰符
        ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符
            /^\uD83D/u.test('\uD83D\uDC2A') // false
            /^\uD83D/.test('\uD83D\uDC2A') // true
    4）RegExp.prototype.unicode 属性
        表示是否设置了u修饰符
            const r1 = /hello/;
            const r2 = /hello/u;

            r1.unicode // false
            r2.unicode // true
    5）y 修饰符
        y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
            var s = 'aaa_aa_a';
            var r1 = /a+/g;
            var r2 = /a+/y;

            r1.exec(s) // ["aaa"]
            r2.exec(s) // ["aaa"]

            r1.exec(s) // ["aa"]
            r2.exec(s) // null
    6）RegExp.prototype.sticky 属性
        表示是否设置了y修饰符
    7）RegExp.prototype.flags 属性
        返回正则表达式的修饰符
            // ES5 的 source 属性
            // 返回正则表达式的正文
            /abc/ig.source
            // "abc"

            // ES6 的 flags 属性
            // 返回正则表达式的修饰符
            /abc/ig.flags
            // 'gi'
    （剩下的还有s 修饰符：dotAll 模式、后行断言等，没看懂，详见教程）
6、数值的扩展
    1）二进制和八进制表示法：ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。
    2）Number.isFinite()：检查一个数值是否为有限的（finite）；
     Number.isNaN()：检查一个值是否为NaN；
    3）Number.parseInt(), Number.parseFloat() ：将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
    4）Number.isInteger()：判断一个数值是否为整数。
    5）Number.EPSILON：一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。
    6）安全整数：2^53到2^53之间（不含两个端点），JavaScript 能够准确表示的整数范围
     Number.isSafeInteger()：判断一个整数是否落在这个范围之内
    7）Math.trunc()：除一个数的小数部分，返回整数部分。
    8）Math.sign() ：判断一个数到底是正数、负数、还是零
        它会返回五种值：
            参数为正数，返回+1；
            参数为负数，返回-1；
            参数为 0，返回0；
            参数为-0，返回-0;
            其他值，返回NaN。
    9）Math.cbrt()：计算一个数的立方根
    10）Math.clz32()：将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。
    11）Math.imul()：返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。
    12）Math.fround()：返回一个数的32位单精度浮点数形式。
    13）Math.hypot()：返回所有参数的平方和的平方根。
    14）Math.expm1()：Math.expm1(x)返回 e(x次方) - 1，即Math.exp(x) - 1。
    15）Math.log1p()：Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。
    16）Math.log10()：返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。
    11）Math.log2()：返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。
    12）双曲函数方法
        ES6 新增了 6 个双曲函数方法。
        Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
        Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
        Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
        Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
        Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
        Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）
    13）指数运算符：（**）
        2 ** 3 // 8
    14）BigInt 数据类型 ：ES2020 引入了一种新的数据类型 BigInt（大整数），是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。
7、函数的扩展
    1)函数参数的默认值
        ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
            function log(x, y = 'World') {
                console.log(x, y);
            }

            log('Hello') // Hello World
            log('Hello', 'China') // Hello China
            log('Hello', '') // Hello
        作为练习，请问下面两种写法有什么差别？

            // 写法一
            function m1({x = 0, y = 0} = {}) {
            return [x, y];
            }

            // 写法二
            function m2({x, y} = { x: 0, y: 0 }) {
            return [x, y];
            }

            // 函数没有参数的情况
            m1() // [0, 0]
            m2() // [0, 0]

            // x 和 y 都有值的情况
            m1({x: 3, y: 8}) // [3, 8]
            m2({x: 3, y: 8}) // [3, 8]

            // x 有值，y 无值的情况
            m1({x: 3}) // [3, 0]
            m2({x: 3}) // [3, undefined]

            // x 和 y 都无值的情况
            m1({}) // [0, 0];
            m2({}) // [undefined, undefined]

            m1({z: 3}) // [0, 0]
            m2({z: 3}) // [undefined, undefined]
        函数的 length 属性：指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
    2）rest参数
        ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了（个人感觉就是一个解构赋值的形参）
            function add(...values) {
                let sum = 0;

            for (var val of values) {
                sum += val;
            }

            return sum;
            }

            add(2, 5, 3) // 10
    3）严格模式
        ES2016规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
            // 报错
            function doSomething(a, b = a) {
                'use strict';
                // code
            }
            这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。
    4）name 属性
        函数的name属性，返回该函数的函数名。
            function foo() {}
            foo.name // "foo"

            var f = function () {};

            // ES5
            f.name // ""

            // ES6
            f.name // "f"
    5）箭头函数
        基本用法：
            var f = () => 5;
            // 等同于
            var f = function () { return 5 };

            var sum = (num1, num2) => num1 + num2;
            // 等同于
            var sum = function(num1, num2) {
            return num1 + num2;
            };
        使用注意点：
            （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

            （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

            （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

            （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
                    function foo() {
                        setTimeout(() => {
                            console.log('id:', this.id);
                        }, 100);
                    }

                    var id = 21;

                    foo.call({ id: 42 });
                    // id: 42
                箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域
                    function Timer() {
                        this.s1 = 0;
                        this.s2 = 0;
                        // 箭头函数
                        setInterval(() => this.s1++, 1000);
                        // 普通函数
                        setInterval(function () {
                            this.s2++;
                        }, 1000);
                    }

                    var timer = new Timer();

                    setTimeout(() => console.log('s1: ', timer.s1), 3100);
                    setTimeout(() => console.log('s2: ', timer.s2), 3100);
                    // s1: 3
                    // s2: 0
    6）尾调用优化
        尾调用：指某个函数的最后一步是调用另一个函数。
            function f(x){
                return g(x);
            }
        尾调用优化：只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。
            function f() {
                let m = 1;
                let n = 2;
                return g(m + n);
            }
            f();

            // 等同于
            function f() {
                return g(3);
            }
            f();

            // 等同于
            g(3);
        *注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。
            function addOne(a){
                var one = 1;
                function inner(b){
                    return b + one;
                }
                return inner(a);
            }
        尾递归：函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
            非尾递归的 Fibonacci 数列实现：
                function Fibonacci (n) {
                    if ( n <= 1 ) {return 1};

                    return Fibonacci(n - 1) + Fibonacci(n - 2);
                }

                Fibonacci(10) // 89
                Fibonacci(100) // 超时
                Fibonacci(500) // 超时
            尾递归优化过的 Fibonacci 数列实现：
                function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
                    if( n <= 1 ) {return ac2};

                    return Fibonacci2 (n - 1, ac2, ac1 + ac2);
                }

                Fibonacci2(100) // 573147844013817200000
                Fibonacci2(1000) // 7.0330367711422765e+208
                Fibonacci2(10000) // Infinity
        严格模式：ES6 的尾调用优化只在严格模式下开启，正常模式是无效的
    7）函数参数的尾逗号
        ES2017 允许函数的最后一个参数有尾逗号
    8）Function.prototype.toString()
        toString()方法，明确要求返回函数一模一样的原始代码，包含注释和空格。
    9）catch 命令的参数省略
        try {
            // ...
        } catch {
            // ...
        }
8、数组的扩展
    1）扩展运算符：三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
        console.log(...[1, 2, 3])
        // 1 2 3
    2）Array.from()：将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）
        let arrayLike = {
            '0': 'a',
            '1': 'b',
            '2': 'c',
            length: 3
        };
        let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
    3）Array.of()：一组值，转换为数组。
        Array.of(3, 11, 8) // [3,11,8]
    4）数组实例的 copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
        Array.prototype.copyWithin(target, start = 0, end = this.length)
        它接受三个参数。
            target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
            start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
            end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。
        [1, 2, 3, 4, 5].copyWithin(0, 3)
        // [4, 5, 3, 4, 5]
    5）数组实例的 find() ：找出第一个符合条件的数组成员；
            [1, 4, -5, 10].find((n) => n < 0)
            // -5
        findIndex()：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
            [1, 5, 10, 15].findIndex(function(value, index, arr) {
                return value > 9;
            }) // 2
    6）数组实例的 fill()：使用给定值，填充一个数组
    7）数组实例的 entries()，keys() 和 values()：用于遍历数组，keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历
    8）数组实例的 includes()：返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。
    9）数组实例的 flat()：将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。（参数设置拉平层数，默认1）
        flatMap()：对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组
    10）数组的空位：ES6 明确将空位转为undefined。空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值。
9、对象的扩展
    1）属性的简洁表示法：ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法
        let birth = '2000/01/01';

        const Person = {

            name: '张三',

            //等同于birth: birth
            birth,

            // 等同于hello: function ()...
            hello() { console.log('我的名字是', this.name); }

        };
        *注意：简写的对象方法不能用作构造函数，会报错
            const obj = {
                f() {
                    this.foo = 'bar';
                }
            };

            new obj.f() // 报错
    2）属性名表达式：ES6 允许字面量定义对象时，把表达式放在方括号内作为对象的属性名。
        let propKey = 'foo';

        let obj = {
            [propKey]: true,
            ['a' + 'bc']: 123
        };
    3）方法的 name 属性 
        const person = {
            sayName() {
                console.log('hello!');
            },
        };

        person.sayName.name   // "sayName"
    4）属性的可枚举性和遍历
        可枚举性：有四个操作会忽略对象enumerable为false的属性
            for...in循环：只遍历对象自身的和继承的可枚举的属性。
            Object.keys()：返回对象自身的所有可枚举的属性的键名。
            JSON.stringify()：只串行化对象自身的可枚举的属性。
            Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
        属性的遍历:
            （1）for...in

            for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

            （2）Object.keys(obj)

            Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

            （3）Object.getOwnPropertyNames(obj)

            Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

            （4）Object.getOwnPropertySymbols(obj)

            Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

            （5）Reflect.ownKeys(obj)

            Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。
    5)super 关键字:指向当前对象的原型对象
            const proto = {
                foo: 'hello'
            };

            const obj = {
                foo: 'world',
                find() {
                    return super.foo;
                }
            };

            Object.setPrototypeOf(obj, proto);
            obj.find() // "hello"
        *注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错
            // 报错
            const obj = {
                foo: super.foo
            }

            // 报错
            const obj = {
                foo: () => super.foo
            }

            // 报错
            const obj = {
                foo: function () {
                    return super.foo
                }
            }
    6)对象的扩展运算符
        解构赋值:对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。
            let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
            x // 1
            y // 2
            z // { a: 3, b: 4 }
            *注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
        扩展运算符：对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
            let z = { a: 3, b: 4 };
            let n = { ...z };
            n // { a: 3, b: 4 }
    7）链判断运算符：?.
            const firstName = (message
            && message.body
            && message.body.user
            && message.body.user.firstName) || 'default';
        简化后：
            const firstName = message?.body?.user?.firstName || 'default';
        注意点：
            （1）短路机制
                ?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行。

                a?.[++x]
                // 等同于
                a == null ? undefined : a[++x]
            （2）delete 运算符
                delete a?.b
                // 等同于
                a == null ? undefined : delete a.b
            （3）括号的影响

                如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。

                (a?.b).c
                // 等价于
                (a == null ? undefined : a.b).c
            （4）报错场合
                以下写法是禁止的，会报错。

                // 构造函数
                new a?.()
                new a?.b()

                // 链判断运算符的右侧有模板字符串
                a?.`{b}`
                a?.b`{c}`

                // 链判断运算符的左侧是 super
                super?.()
                super?.foo

                // 链运算符用于赋值运算符左侧
                a?.b = c
            （5）右侧不得为十进制数值

                为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。
    8)Null 判断运算符:ES2020 引入了一个新的 Null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。
            const headerText = response.settings.headerText || 'Hello, world!';
            const animationDuration = response.settings.animationDuration || 300;
            const showSplashScreen = response.settings.showSplashScreen || true;
        简化后：
            const headerText = response.settings.headerText ?? 'Hello, world!';
            const animationDuration = response.settings.animationDuration ?? 300;
            const showSplashScreen = response.settings.showSplashScreen ?? true;

        应用：跟链判断运算符?.配合使用，为null或undefined的值设置默认值。
            const animationDuration = response.settings?.animationDuration ?? 300;
10、对象的新增方法
    1）Object.is()：比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
    2）Object.assign()：Object.assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
        const target = { a: 1 };

        const source1 = { b: 2 };
        const source2 = { c: 3 };

        Object.assign(target, source1, source2);
        target // {a:1, b:2, c:3}
        *注意：
        （1）浅拷贝：bject.assign()方法实行的是浅拷贝，而不是深拷贝。
        （2）同名属性的替换：对于嵌套的对象，一旦遇到同名属性，Object.assign()的处理方法是替换，而不是添加。
            const target = { a: { b: 'c', d: 'e' } }
            const source = { a: { b: 'hello' } }
            Object.assign(target, source)
            // { a: { b: 'hello' } }
        （3）数组的处理：处理数组时，会把数组视为对象。
            Object.assign([1, 2, 3], [4, 5])
            // [4, 5, 3]
            上面代码中，Object.assign()把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。
        （4）取值函数的处理：Object.assign()只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
            const source = {
                get foo() { return 1 }
            };
            const target = {};

            Object.assign(target, source)
            // { foo: 1 }
    3）Object.getOwnPropertyDescriptors()：返回某个对象属性的描述对象
    4）__proto__属性：读取或设置当前对象的原型对象；
        Object.setPrototypeOf()：作用与__proto__相同，用来设置一个对象的原型对象；
        Object.getPrototypeOf()：读取一个对象的原型对象
    5）Object.keys()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
        Object.values()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
        Object.entries()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
    6）Object.fromEntries()：将一个键值对数组转为对象。
11、Symbol
    1）概述：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
            let s = Symbol();

            typeof s
            // "symbol"
        *注意：Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象
        *注意：Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
            // 没有参数的情况
            let s1 = Symbol();
            let s2 = Symbol();

            s1 === s2 // false

            // 有参数的情况
            let s1 = Symbol('foo');
            let s2 = Symbol('foo');

            s1 === s2 // false
    2）Symbol.prototype.description
        const sym = Symbol('foo');

        sym.description // "foo"
    3）作为属性名的 Symbol 
        let mySymbol = Symbol();

        // 第一种写法
        let a = {};
        a[mySymbol] = 'Hello!';

        // 第二种写法
        let a = {
        [mySymbol]: 'Hello!'
        };

        // 第三种写法
        let a = {};
        Object.defineProperty(a, mySymbol, { value: 'Hello!' });

        // 以上写法都得到同样结果
        a[mySymbol] // "Hello!"
        *注意：Symbol 值作为对象属性名时，不能用点运算符
            const mySymbol = Symbol();
            const a = {};

            a.mySymbol = 'Hello!';
            a[mySymbol] // undefined
            a['mySymbol'] // "Hello!"
    4）属性名的遍历
        Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。
    5）Symbol.for()，Symbol.keyFor()
        Symbol.for()：Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。
            let s1 = Symbol.for('foo');
            let s2 = Symbol.for('foo');

            s1 === s2 // true
        Symbol.keyFor()：返回一个已登记的 Symbol 类型值的key。
            let s1 = Symbol.for("foo");
            Symbol.keyFor(s1) // "foo"

            let s2 = Symbol("foo");
            Symbol.keyFor(s2) // undefined
    6）内置的 Symbol 值
    。。。
12、Set 和 Map 数据结构
    1）Set
        定义：类似于数组，但是成员的值都是唯一的，没有重复的值。
            const s = new Set();

            [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));

            for (let i of s) {
            console.log(i);
            }
            // 2 3 5 4
        实例方法：
            Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
            Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
            Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
            Set.prototype.clear()：清除所有成员，没有返回值。
        遍历操作：
            Set.prototype.keys()：返回键名的遍历器
            Set.prototype.values()：返回键值的遍历器
            Set.prototype.entries()：返回键值对的遍历器
            Set.prototype.forEach()：使用回调函数遍历每个成员
    2）WeakSet
        含义：eakSet 结构与 Set 类似，也是不重复的值的集合。WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
    3）Map
        含义和基本用法：类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
            const m = new Map();
            const o = {p: 'Hello World'};

            m.set(o, 'content')
            m.get(o) // "content"

            m.has(o) // true
            m.delete(o) // true
            m.has(o) // false
        实例的属性和操作方法：
            size 属性：返回 Map 结构的成员总数
            Map.prototype.set(key, value)：设置键名key对应的键值为value，然后返回整个 Map 结构
            Map.prototype.get(key)：读取key对应的键值，如果找不到key，返回undefined。
            Map.prototype.has(key)：返回一个布尔值，表示某个键是否在当前 Map 对象之中。
            Map.prototype.delete(key)：删除某个键，返回true。如果删除失败，返回false。
            Map.prototype.clear()：清除所有成员，没有返回值。
        遍历方法：
            Map.prototype.keys()：返回键名的遍历器。
            Map.prototype.values()：返回键值的遍历器。
            Map.prototype.entries()：返回所有成员的遍历器。
            Map.prototype.forEach()：遍历 Map 的所有成员。
    4）WeakMap
        含义：WeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。WeakMap的键名所指向的对象，不计入垃圾回收机制。
13、Proxy
    1）概述：Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程（Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。有点重载的概念）。
        var obj = new Proxy({}, {
            get: function (target, propKey, receiver) {
                console.log(`getting ${propKey}!`);
                return Reflect.get(target, propKey, receiver);
            },
            set: function (target, propKey, value, receiver) {
                console.log(`setting ${propKey}!`);
                return Reflect.set(target, propKey, value, receiver);
            }
        });
        obj.count = 1
        //  setting count!
        ++obj.count
        //  getting count!
        //  setting count!
        //  2
    2）Proxy 支持的拦截操作一览，一共 13 种：
        get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
        set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
        has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
        deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
        ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
        getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
        defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
        preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
        getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
        isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
        setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
        apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
        construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
14、Reflect
    1）概述：Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API
        设计目的：
            （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。
            （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
            （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。
            （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。
        例：
            var loggedObj = new Proxy(obj, {
                get(target, name) {
                    console.log('get', target, name);
                    return Reflect.get(target, name);
                },
                deleteProperty(target, name) {
                    console.log('delete' + name);
                    return Reflect.deleteProperty(target, name);
                },
                has(target, name) {
                    console.log('has' + name);
                    return Reflect.has(target, name);
                }
            });
    2）静态方法
        Reflect对象一共有 13 个静态方法。

            Reflect.apply(target, thisArg, args)
            Reflect.construct(target, args)
            Reflect.get(target, name, receiver)
            Reflect.set(target, name, value, receiver)
            Reflect.defineProperty(target, name, desc)
            Reflect.deleteProperty(target, name)
            Reflect.has(target, name)
            Reflect.ownKeys(target)
            Reflect.isExtensible(target)
            Reflect.preventExtensions(target)
            Reflect.getOwnPropertyDescriptor(target, name)
            Reflect.getPrototypeOf(target)
            Reflect.setPrototypeOf(target, prototype)
15、Promise 对象
    1）Promise 的含义
        含义：所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
        特点：
            （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
            （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
        缺点：
            （1）无法取消Promise，一旦新建它就会立即执行，无法中途取消
            （2）如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
            （3）当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
    2）基本用法
        const promise = new Promise(function(resolve, reject) {
            // ... some code

            if (/* 异步操作成功 */){
                resolve(value);
            } else {
                reject(error);
            }
        });

        promise.then(function(value) {
            // success
        }, function(error) {
            // failure
        });
    3）Promise.prototype.then()
        概念：Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。
            then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。
                getJSON("/posts.json").then(function(json) {
                    return json.post;
                }).then(function(post) {
                    // ...
                });
    4）Promise.prototype.catch()
        概念：Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。

            getJSON('/posts.json').then(function(posts) {
                // ...
            }).catch(function(error) {
                // 处理 getJSON 和 前一个回调函数运行时发生的错误
                console.log('发生错误！', error);
            });
    5）Promise.prototype.finally()
        概念：finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。
            promise
            .then(result => {···})
            .catch(error => {···})
            .finally(() => {···});
    6）Promise.all()
        概念：Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
            const p = Promise.all([p1, p2, p3]);
        p的状态由p1、p2、p3决定，分成两种情况。

            （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。

            （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
    7）Promise.race()
        概念：Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
            const p = Promise.race([p1, p2, p3]);
        上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
    8）Promise.allSettled() 
        概念：Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。
    9）Promise.any()
        概念：接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。
        区别：Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。
    10）Promise.resolve()
        作用：将现有对象转为 Promise 对象
        四种情况：
            （1）参数是一个 Promise 实例

                如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。
            （2）参数是一个thenable对象（具有then方法的对象）
                Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。
                    let thenable = {
                        then: function(resolve, reject) {
                            resolve(42);
                        }
                    };

                    let p1 = Promise.resolve(thenable);
                    p1.then(function (value) {
                        console.log(value);  // 42
                    });
            （3）参数不是具有then()方法的对象，或根本就不是对象

                如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。
            （4）不带有任何参数

                Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。
    11）Promise.reject() 
        概念：Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。
16、Iterator 和 for...of 循环（较粗略）
    1）Iterator（遍历器）的概念：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
    2）作用：一是为各种数据结构，提供一个统一的、简便的访问接口；
        二是使得数据结构的成员能够按某种次序排列；
        三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
    3）遍历过程：
        （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

        （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。

        （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。

        （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。
        每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。
            var it = makeIterator(['a', 'b']);

            it.next() // { value: "a", done: false }
            it.next() // { value: "b", done: false }
            it.next() // { value: undefined, done: true }

            function makeIterator(array) {
                var nextIndex = 0;
                return {
                    next: function() {
                    return nextIndex < array.length ?
                        {value: array[nextIndex++], done: false} :
                        {value: undefined, done: true};
                    }
                };
            }
    4）for...of 循环：遍历所有数据结构的统一的方法。
        概念：一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。
            for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。
17、Generator 函数的语法
    1）简介：一种异步编程解决方案，语法行为与传统函数完全不同；状态机+遍历器对象，封装了多个内部状态，可以依次遍历 Generator 函数内部的每一个状态。
        特征：一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
            function* helloWorldGenerator() {
                yield 'hello';
                yield 'world';
                return 'ending';
            }

            var hw = helloWorldGenerator();
            代码说明：上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。
            然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。
            下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。
            hw.next()
            // { value: 'hello', done: false }

            hw.next()
            // { value: 'world', done: false }

            hw.next()
            // { value: 'ending', done: true }

            hw.next()
            // { value: undefined, done: true }
        总结：调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束
            ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。
        yield 表达式：Generator 函数返回的遍历器对象暂停执行的标志；
        next()运行逻辑：
            （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。

            （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。

            （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。

            （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。
        yield与return的区别：
            （1）yield具备位置记忆功能；
            （2）yield表达式可以有多个；
        *注意：yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。
    2）next 方法的参数
        概念：yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
            function* foo(x) {
                var y = 2 * (yield (x + 1));
                var z = yield (y / 3);
                return (x + y + z);
            }

            var a = foo(5);
            a.next() // Object{value:6, done:false}
            a.next() // Object{value:NaN, done:false}
            a.next() // Object{value:NaN, done:true}

            var b = foo(5);
            b.next() // { value:6, done:false }
            b.next(12) // { value:8, done:false }
            b.next(13) // { value:42, done:true }
            代码说明：上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。
    3）for...of 循环
        概念：for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。
            function* foo() {
                yield 1;
                yield 2;
                yield 3;
                yield 4;
                yield 5;
                return 6;
            }

            for (let v of foo()) {
                console.log(v);
            }
            // 1 2 3 4 5
        例：利用 Generator 函数和for...of循环，实现斐波那契数列
            function* fibonacci() {
                let [prev, curr] = [0, 1];
                for (;;) {
                    yield curr;
                    [prev, curr] = [curr, prev + curr];
                }
            }

            for (let n of fibonacci()) {
                if (n > 1000) break;
                console.log(n);
            }
    4）Generator.prototype.throw()
        概念：Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。
            var g = function* () {
                try {
                    yield;
                } catch (e) {
                    console.log('内部捕获', e);
                }
            };

            var i = g();
            i.next();

            try {
                i.throw('a');
                i.throw('b');
                } catch (e) {
                console.log('外部捕获', e);
            }
            // 内部捕获 a
            // 外部捕获 b
            说明：上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。
    5）Generator.prototype.return()
        概念：可以返回给定的值，并且终结遍历 Generator 函数。
            function* gen() {
                yield 1;
                yield 2;
                yield 3;
            }

            var g = gen();

            g.next()        // { value: 1, done: false }
            g.return('foo') // { value: "foo", done: true }
            g.next()        // { value: undefined, done: true }
            说明：遍历器对象g调用return()方法后，返回值的value属性就是return()方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next()方法，done属性总是返回true。
    6）next()、throw()、return() 的共同点
        共同点：next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。
        不同点：next()是将yield表达式替换成一个值。throw()是将yield表达式替换成一个throw语句。return()是将yield表达式替换成一个return语句。
    7）yield* 表达式
        作用：用来在一个 Generator 函数里面执行另一个 Generator 函数。
            function* foo() {
                yield 'a';
                yield 'b';
            }
            function* bar() {
                yield 'x';
                yield* foo();
                yield 'y';
            }

            // 等同于
            function* bar() {
                yield 'x';
                yield 'a';
                yield 'b';
                yield 'y';
            }

            // 等同于
            function* bar() {
                yield 'x';
                for (let v of foo()) {
                    yield v;
                }
                yield 'y';
            }

            for (let v of bar()){
                console.log(v);
            }
            // "x"
            // "a"
            // "b"
            // "y"
        对比例子：
            function* inner() {
                yield 'hello!';
            }

            function* outer1() {
                yield 'open';
                yield inner();
                yield 'close';
            }

            var gen = outer1()
            gen.next().value // "open"
            gen.next().value // 返回一个遍历器对象
            gen.next().value // "close"

            function* outer2() {
                yield 'open'
                yield* inner()
                yield 'close'
            }

            var gen = outer2()
            gen.next().value // "open"
            gen.next().value // "hello!"
            gen.next().value // "close"
    8）作为对象属性的 Generator 函数
        let obj = {
            * myGeneratorMethod() {
                ···
            }
        };
    9）Generator 函数的this
        概念：如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。
            function* g() {
                this.a = 11;
            }

            let obj = g();
            obj.next();
            obj.a // undefined
    10）含义
        Generator 与状态机：Generator 是实现状态机的最佳结构
                var ticking = true;
                var clock = function() {
                if (ticking)
                    console.log('Tick!');
                else
                    console.log('Tock!');
                ticking = !ticking;
                }
            说明：clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。
            Generator实现：
                var clock = function* () {
                    while (true) {
                        console.log('Tick!');
                        yield;
                        console.log('Tock!');
                        yield;
                    }
                };
        Generator 与协程
        Generator 与上下文 
        （期待下回分解）
18、Generator 函数的异步应用
19、async 函数
    1）含义：就是 Generator 函数的语法糖
        对比实例：依次读取两个文件
        Generator 函数：
            const fs = require('fs');

            const readFile = function (fileName) {
            return new Promise(function (resolve, reject) {
                fs.readFile(fileName, function(error, data) {
                if (error) return reject(error);
                resolve(data);
                });
            });
            };

            const gen = function* () {
            const f1 = yield readFile('/etc/fstab');
            const f2 = yield readFile('/etc/shells');
            console.log(f1.toString());
            console.log(f2.toString());
            };
        async函数：
            const asyncReadFile = async function () {
                const f1 = await readFile('/etc/fstab');
                const f2 = await readFile('/etc/shells');
                console.log(f1.toString());
                console.log(f2.toString());
            };
        总结：async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。
        async函数对 Generator 函数的改进：
            （1）内置执行器。调用函数，自动执行，输出结果，无需调用next()方法
            （2）更好的语义。
            （3）更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
            （4）返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。
    2）基本用法：async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
        async function getStockPriceByName(name) {
            const symbol = await getStockSymbol(name);
            const stockPrice = await getStockPrice(symbol);
            return stockPrice;
        }

        getStockPriceByName('goog').then(function (result) {
            console.log(result);
        });
    3）语法
        返回 Promise 对象：
        Promise 对象的状态变化：只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。
        await 命令：正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。
    4）async 函数的实现原理
        async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。
            async function fn(args) {
            // ...
            }

            // 等同于

            function fn(args) {
            return spawn(function* () {
                // ...
            });
            }
20、Class 的基本语法
    1）简介：通过class关键字，可以定义类。可以看作只是一个语法糖。
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            toString() {
                return '(' + this.x + ', ' + this.y + ')';
            }
        }
        constructor 方法：constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。constructor()方法默认返回实例对象（即this），完全可以指定返回另外一个对象。
        类的实例：
            class Point {
                // ...
            }

            // 报错
            var point = Point(2, 3);

            // 正确
            var point = new Point(2, 3);
        取值函数（getter）和存值函数（setter）：
            class MyClass {
                constructor() {
                    // ...
                }
                get prop() {
                    return 'getter';
                }
                set prop(value) {
                    console.log('setter: '+value);
                }
            }

            let inst = new MyClass();

            inst.prop = 123;
            // setter: 123

            inst.prop
            // 'getter'
        *注意：
            （1）严格模式：类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。
            （2）不存在提升：类不存在变量提升（hoist），这一点与 ES5 完全不同。
            （3）name 属性：class Point {};Point.name // "Point"
            （4）Generator 方法：如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。
            （5）this 的指向：类的方法内部如果含有this，它默认指向类的实例。
    2）静态方法 
        class Foo {
            static classMethod() {
                return 'hello';
            }
        }

        Foo.classMethod() // 'hello'

        var foo = new Foo();
        foo.classMethod()
        // TypeError: foo.classMethod is not a function
        *注意：如果静态方法包含this关键字，这个this指的是类，而不是实例。
    3）例属性的新写法
        概念：实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。
            class IncreasingCounter {
                constructor() {
                    this._count = 0;
                }
                get value() {
                    console.log('Getting the current value!');
                    return this._count;
                }
                increment() {
                    this._count++;
                }
            }
    4）静态属性（只能这么写）
        class Foo {
        }

        Foo.prop = 1;
        Foo.prop // 1
    5）私有方法和私有属性（提案）
21、Class 的继承
    1）简介：Class 可以通过extends关键字实现继承
        class Point {
        }

        class ColorPoint extends Point {
            constructor(x, y, color) {
                super(x, y); // 调用父类的constructor(x, y)
                this.color = color;
            }

            toString() {
                return this.color + ' ' + super.toString(); // 调用父类的toString()
            }
        }
        *注意：（1）子类必须在constructor方法中调用super方法。
            （2）在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错
            （3）父类的静态方法，也会被子类继承
    2）Object.getPrototypeOf()
        Object.getPrototypeOf方法可以用来从子类上获取父类。

            Object.getPrototypeOf(ColorPoint) === Point
            // true
        因此，可以使用这个方法判断，一个类是否继承了另一个类。
    3）super 关键字
        概念：super这个关键字，既可以当作函数使用，也可以当作对象使用。
        用法：（1）super作为函数调用时，代表父类的构造函数，super()只能用在子类的构造函数之中，用在其他地方就会报错。
            *注意：super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)
            （2）super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
                class A {
                    p() {
                        return 2;
                    }
                }

                class B extends A {
                    constructor() {
                        super();
                        console.log(super.p()); // 2
                    }
                }

                let b = new B();
    4）类的 prototype 属性和__proto__属性
        （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。

        （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。
        实例的 __proto__ 属性：子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。
    5）原生构造函数的继承（无法继承）
    6）Mixin 模式的实现
        概念：Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。
            function mix(...mixins) {
                class Mix {
                    constructor() {
                    for (let mixin of mixins) {
                        copyProperties(this, new mixin()); // 拷贝实例属性
                    }
                    }
                }

                for (let mixin of mixins) {
                    copyProperties(Mix, mixin); // 拷贝静态属性
                    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
                }

                return Mix;
            }

            function copyProperties(target, source) {
                for (let key of Reflect.ownKeys(source)) {
                    if ( key !== 'constructor'
                    && key !== 'prototype'
                    && key !== 'name'
                    ) {
                    let desc = Object.getOwnPropertyDescriptor(source, key);
                    Object.defineProperty(target, key, desc);
                    }
                }
            }
            class DistributedEdit extends mix(Loggable, Serializable) {
                // ...
            }
22、Module 的语法
    1）概述：通过export命令显式指定输出的代码，再通过import命令输入
        // ES6模块
        import { stat, exists, readFile } from 'fs';
        *注意：ES6 模块是编译时加载
    2）严格模式：ES6 的模块自动采用严格模式
        严格模式主要有以下限制：
            变量必须声明后再使用
            函数的参数不能有同名属性，否则报错
            不能使用with语句
            不能对只读属性赋值，否则报错
            不能使用前缀 0 表示八进制数，否则报错
            不能删除不可删除的属性，否则报错
            不能删除变量delete prop，会报错，只能删除属性delete global[prop]
            eval不会在它的外层作用域引入变量
            eval和arguments不能被重新赋值
            arguments不会自动反映函数参数的变化
            不能使用arguments.callee
            不能使用arguments.caller
            禁止this指向全局对象
            不能使用fn.caller和fn.arguments获取函数调用的堆栈
            增加了保留字（比如protected、static和interface）
    3）export 命令
        概述：export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
        语法：
            输出变量：
                export var firstName = 'Michael';
            输出对象：
                var firstName = 'Michael';
                var lastName = 'Jackson';
                var year = 1958;

                export { firstName, lastName, year };
            可以使用as关键字重命名：
                function v1() { ... }
                function v2() { ... }

                export {
                    v1 as streamV1,
                    v2 as streamV2,
                    v2 as streamLatestVersion
                };
            *注意：export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。
                // 报错
                export 1;

                // 报错
                var m = 1;
                export m;
    4）import 命令
        概念：使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。
        语法：import { firstName, lastName, year } from './profile.js';
                说明：上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。
            使用as关键字，将输入的变量重命名：
                import { lastName as surname } from './profile.js';
        *注意：
            （1）import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。
                import {a} from './xxx.js'
                a = {}; // Syntax Error : 'a' is read-only;
            （2）import命令具有提升效果，会提升到整个模块的头部，首先执行。
    5)模块的整体加载
        概念：除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。
        语法：
            export function area(radius) {
                return Math.PI * radius * radius;
            }

            export function circumference(radius) {
                return 2 * Math.PI * radius;
            }
            import * as circle from './circle';
    6）export default 命令
        概念：用export default命令，为模块指定默认输出。其他模块加载该模块时，import命令可以指定任意名字。
        语法：
            // export-default.js
            export default function () {
                console.log('foo');
            }
            // import-default.js
            import customName from './export-default';
            customName(); // 'foo'
    7）export 与 import 的复合写法
        export { foo, bar } from 'my_module';

        // 可以简单理解为
        import { foo, bar } from 'my_module';
        export { foo, bar };
23、Module 的加载实现
24、编程风格
25、读懂规格
26、异步遍历器
27、ArrayBuffer
28、最新提案
29、Decorator
30、参考链接

