第一章：绪论
  数据结构：指相互之间存在某种特定关系的数据元素的集合；
  算法：是对特定问题求解步骤的一种描述，是指令的有限序列；
    5个重要特性：1）有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在合理可接受时间内完成；
                2）确定性：算法中每一条指令必须有确切的含义，读者理解时不会产生二义性；
                3）可行性：一个算法是可行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
                4）输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合；
                5）输出：一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量
    设计要求：1）正确性：算法应当满足具体问题的需求；
             2）可读性：
             3）健壮性：党输入数据非法时，算法也能适当的作出反应或进行处理，而不会产生莫名其妙的输出结果；
             4）效率与低存储量需求：效率指算法的执行时间。存储量需求指算法执行过程中所需要的最大存储空间。
第二章：线性表
  线性表：是具有相同数据类型的n(n>=0)个数据元素的有限序列，通常记为（a1,a2,a3,a4,a5,a6...,an）；
    顺序表（线性表的顺序表示）：即在内存中用地址连续有限的一块存储空间依次顺序存放线性表的各个元素的存储形式存储的线性表；
    线性链表：以链式结构存储的线性表；
第三章：栈和队列
  栈（堆栈）：仅允许在一端进行插入和删除操作的线性表；该位置位于表尾，称为栈顶，相对的，另一端称为栈底；
            （由于栈的插入和删除运算仅在栈顶一端进行，后进栈的元素必定先出栈，所以又把栈称为后进先出表，简称LIFO，Last In First Out）
    顺序栈：即栈的顺序存储表示，是指利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，用指针bottom指示栈底元素在存储器中的位置，
            用指针top指示栈顶元素在存储器中的位置，同时，用变量stacksize来指示当前栈的最大可用容量；
    链栈：栈的链式存储表示。与线性链表类似，用一组任意的存储单元来存储栈中的数据元素，栈中的每一个元素用一个结点表示，每一个结点由一个数据域和指针域组成。
          其中，数据域用来存放数据元素，指针域用来存储直接后继的位置。同时设一个指针top，用来指示栈顶元素所在结点的存储位置。
  队列：只允许在一端进行插入操作，而在另一端进行删除操作的线性表。只允许插入的一端称为队尾，只允许删除的一端称为对头。
第四章：数组
  数组：是类型相同的元素构成的有序集合，每个元素成为一个数组元素，每个元素在n个线性关系中的序号i1,i2,i3...in表示该元素的下标，可以通过下标访问该数据元素。
        （数组一旦定义，其结构和元素之间的关系不再发生改变，因此，采用顺序存储结构表示数组是比较合适的）
第五章：树
  树：是n(n>=0)个结点的有限集。
    结点的度：结点拥有的子树；
    叶子（终端结点）：度为0的结点；
    分支结点（非终端结点）：度不为0的结点；
    树的度：一棵树中各个结点的度的最大值；
    树的深度（高度）：树中结点的最大层次值；
    有序树：在一棵树中，如果同层的孩子结点左右互换位置会是的表达的意思发生变化；
    无序树：反之有序树；
    树的基本特征：
      1）一棵有n个结点组成的树，其边的数目必定是n-1。
      2）在一棵树中，从任意一个结点到另一个任意结点之间的路径有且仅有一条；
  二叉树：每个结点至多有两棵子树（即二叉树中不存在度大于2的结点）。而且，二叉树是一种有序树。
    重要性质：
      1）在二叉树的第i层上至多有2^(i-1)个结点（i>=1）；
      2）深度为k的二叉树至多有2^i-1个结点（k<=1）;
      3）对任何一棵二叉树T，如果其终端结点数为n0，度为2的节点数为n2，则n0 = n2 + 1;
    遍历二叉树：
      1）先序遍历：根，左，右
      2）中序遍历：左，根，右
      3）后序遍历：左，右，根
    线索：指向结点前驱和后继的指针；
    线索链表：加上线索的二叉链表；
    线索二叉树：加上线索的二叉树；（为实现遍历而添加的线索）
              （试做如下规定：在二叉链表中，如果结点有左子树，则其Lch域（左孩子指针）指向其左孩子，如果没有，则指向本结点的前驱结点。
              同时，如果结点有右子树，则其Rch域（右孩子指针）指向其右孩子，如果没有，则指向本结点的后继结点）
    树转换为二叉树：
      1）加线：在所有兄弟结点之间加一条线；
      2）去线：对树中的每一个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点的连线；
      3）调整形状：以树的根结点为轴心，长子连线为左孩子，兄弟连线为右孩子，将各个结点进行移动，使之看上去层次分明；
    哈夫曼树（最优二叉树）：假设有n个权值{W1,W2,W3,W4...Wn}，试构造一棵有n个叶子结点的二叉树，每个叶子结点带权为wi，
                          则其中带权路径长度WPL最小的二叉树称作最优二叉树或哈夫曼树；
    树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作WPL = w1l1 + w2l2 + w3l3 +...+ wnln;
    哈夫曼树的推论即性质：
      1）叶子上的权值均相同时，完全二叉树一定是哈夫曼树；若叶子的权值不相同，则完全二叉树不一定是哈夫曼树；
      2）哈夫曼树中没有度为1的结点，即n1 = 0;
      3）在哈夫曼树中，权值较大的叶子离根的距离<=权值较小的叶子离根的距离；
      4）哈夫曼树是无序树，左右可随意交换，甚至树高也不唯一，只要该树的WPL值等于最小值即可；
      5）对于一棵有n个叶子结点的哈夫曼树，根据二叉树的性质3，无论哈夫曼树呈现什么样的形状，其节点总数必为2n - 1;
第六章：图
  图：是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)其中G表示一个图，V是图中顶点的集合，E是图中连线的集合。
第七章：查找
  二叉排序树：二叉排序树或是一棵空树，或者具有下列性质：
              1）若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
              2）若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
              3）它的左、右子树也分别是二叉排序树；
  哈希查找（散列表查找）：在记录的位置和它的关键字之间建立一个确定的映射关系f，使得每一个关键字key对应一个存储位置f(key)。
  哈希函数（散列函数）：这种映射关系f；
  哈希表（散列表）：当我们采用哈希函数将记录存储在一块连续的存储空间里时，这块连续的存储空间称为哈希表。
第八章：排序
  冒泡排序：对相邻两个元素进行比较，如果有序则不做操作，如果相邻的元素不符合有序，则交换之。
          稳定，时间复杂度O(n^2)，空间复杂度O(1)；
  简单选择排序：从序列中依次选取最小的、次小的、。。。与相对应该元素所在位置元素交换，来获得最终有序结果。
          不稳定，时间复杂度O(n^2)，空间复杂度O(1)；
  直接插入排序：将一个元素插入到有序序列当中，让该序列依然有序；初始时将第一个元素看作有序。
          稳定，时间复杂度O(n^2)，空间复杂度O(1)；
  希尔排序：以增量d进行分组，分别对每一组进行直接插入排序。
          不稳定，时间复杂度O(n^1.3~n^1.5)，空间复杂度O(1)；
  快速排序：通过一个元素（该元素称为枢轴），将剩余元素分割为两部分，小的在该元素前，大的在该元素后。然后再对左右两部分元素分别用该思想进行分割，直到最后有序。
          不稳定，平均时间复杂度O(n㏒₂n)，最坏时间复杂度O(n^2)，空间复杂度O(㏒₂n)
  堆排序：（大堆顶）堆是一棵完全二叉树，该二叉树树根最大（大于等于其他所有结点和叶子），其上每一棵子树的树根均大于等于子树上的其他结点和叶子。小堆顶反之；
          不稳定，时间复杂度O(n㏒₂n)，空间复杂度O(1)
  归并排序：依靠递归思维，将两个有序序列合并为一个有序序列。
          稳定，时间复杂度O(n㏒₂n)，空间复杂度O(n)



  
